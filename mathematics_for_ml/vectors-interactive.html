<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Vector Operations</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.155.0/build/three.module.js"
        }
      }
    </script>
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"
      rel="stylesheet"
    />
    <!-- Interactive Vector Operations Laboratory -->
    <!--
    Application Structure: Single-page interactive laboratory with:
    - Fixed sidebar: Control panel with vector sliders, magnitude/angle readouts, and navigation
    - Main content: Two-column grid showing algebraic formulas and live Chart.js visualizations
    - Real-time feedback: Slider changes instantly update all mathematical and geometric representations
    -->
    <!--
    Implementation Details:
    - Vector Controls: HTML range sliders with JavaScript event listeners for real-time updates
    - Visualizations: Chart.js scatter plots (no SVG/Mermaid) with custom arrowhead plugin
    - 3D Cross Product: Three.js WebGL rendering with mouse orbit controls
    - Mathematical Notation: HTML-based bold italic vectors with live value updates
    -->
    <style>
      body {
        font-family: "Inter", sans-serif;
        background-color: #f8fafc;
      }

      /* Navigation active state */
      .nav-link.active {
        background-color: #4f46e5 !important; /* Indigo-600 to match reset button */
        color: white !important;
      }

      .chart-container {
        position: relative;
        width: 100%;
        max-width: 500px;
        height: 90vw;
        max-height: 500px;
        margin: auto;
      }
      @media (min-width: 640px) {
        .chart-container {
          height: 100%;
        }
      }
      html {
        scroll-behavior: smooth;
      }
      input[type="range"] {
        -webkit-appearance: none;
        appearance: none;
        width: 100%;
        background: transparent;
      }
      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        height: 16px;
        width: 16px;
        border-radius: 50%;
        background: #4f46e5;
        cursor: pointer;
        margin-top: -6px;
      }
      input[type="range"]::-moz-range-thumb {
        height: 16px;
        width: 16px;
        border-radius: 50%;
        background: #4f46e5;
        cursor: pointer;
      }
      input[type="range"]::-webkit-slider-runnable-track {
        width: 100%;
        height: 4px;
        cursor: pointer;
        background: #94a3b8;
        border-radius: 2px;
      }
      input[type="range"]::-moz-range-track {
        width: 100%;
        height: 4px;
        cursor: pointer;
        background: #94a3b8;
        border-radius: 2px;
      }
    </style>
  </head>
  <body class="text-slate-800">
    <div class="flex flex-col md:flex-row min-h-screen">
      <aside
        class="w-full md:w-72 bg-slate-800 text-white p-6 md:sticky top-0 md:h-screen z-10 flex flex-col"
      >
        <div>
          <h1 class="text-2xl font-bold mb-4">Vector Explorer</h1>
          <nav>
            <ul class="space-y-1">
              <li>
                <a
                  href="#introduction"
                  class="nav-link block py-2 px-3 rounded-lg hover:bg-slate-700 transition-colors"
                  >Introduction</a
                >
              </li>
              <li>
                <a
                  href="#addition"
                  class="nav-link block py-2 px-3 rounded-lg hover:bg-slate-700 transition-colors"
                  >Addition</a
                >
              </li>
              <li>
                <a
                  href="#subtraction"
                  class="nav-link block py-2 px-3 rounded-lg hover:bg-slate-700 transition-colors"
                  >Subtraction</a
                >
              </li>
              <li>
                <a
                  href="#scalar"
                  class="nav-link block py-2 px-3 rounded-lg hover:bg-slate-700 transition-colors"
                  >Scalar Multiplication</a
                >
              </li>
              <li>
                <a
                  href="#dot"
                  class="nav-link block py-2 px-3 rounded-lg hover:bg-slate-700 transition-colors"
                  >Dot Product</a
                >
              </li>
              <li>
                <a
                  href="#cross"
                  class="nav-link block py-2 px-3 rounded-lg hover:bg-slate-700 transition-colors"
                  >Cross Product</a
                >
              </li>
            </ul>
          </nav>
        </div>
        <div class="mt-6 pt-6 border-t border-slate-600 flex-grow">
          <h2 class="text-xl font-bold mb-3">Controls</h2>
          <div class="space-y-4 text-sm">
            <!-- Vector v Controls -->
            <div class="p-3 bg-slate-700 rounded-lg">
              <label class="font-bold text-base text-red-400"
                >Vector v = (<span id="vx-val-display">2</span>,
                <span id="vy-val-display">4</span>)</label
              >
              <div class="text-xs space-y-1 mt-2">
                <p>Magnitude: <span id="v-mag-display" class="font-mono">4.47</span></p>
                <p>Angle: <span id="v-angle-display" class="font-mono">63.4°</span></p>
              </div>
              <div class="mt-3 space-y-3">
                <div>
                  <label for="vx" class="font-medium">v_x</label>
                  <input
                    type="range"
                    id="vx"
                    min="-10"
                    max="10"
                    value="2"
                    step="0.5"
                    class="w-full"
                  />
                </div>
                <div>
                  <label for="vy">v_y</label>
                  <input
                    type="range"
                    id="vy"
                    min="-10"
                    max="10"
                    value="4"
                    step="0.5"
                    class="w-full"
                  />
                </div>
              </div>
            </div>
            <!-- Vector w Controls -->
            <div class="p-3 bg-slate-700 rounded-lg">
              <label class="font-bold text-base text-green-400"
                >Vector w = (<span id="wx-val-display">5</span>,
                <span id="wy-val-display">1</span>)</label
              >
              <div class="text-xs space-y-1 mt-2">
                <p>Magnitude: <span id="w-mag-display" class="font-mono">5.10</span></p>
                <p>Angle: <span id="w-angle-display" class="font-mono">11.3°</span></p>
              </div>
              <div class="mt-3 space-y-3">
                <div>
                  <label for="wx" class="font-medium">w_x</label>
                  <input
                    type="range"
                    id="wx"
                    min="-10"
                    max="10"
                    value="5"
                    step="0.5"
                    class="w-full"
                  />
                </div>
                <div>
                  <label for="wy">w_y</label>
                  <input
                    type="range"
                    id="wy"
                    min="-10"
                    max="10"
                    value="1"
                    step="0.5"
                    class="w-full"
                  />
                </div>
              </div>
            </div>

            <!-- Reset Button -->
            <button
              id="reset-button"
              class="w-full mt-4 px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white font-medium rounded-lg transition-colors"
            >
              Reset
            </button>
          </div>
        </div>
      </aside>

      <main class="flex-1 p-6 sm:p-8 md:p-10">
        <section id="introduction" class="mb-12 scroll-mt-20">
          <h2 class="text-3xl font-bold text-slate-900 border-b-2 border-indigo-200 pb-2 mb-4">
            Introduction to Vectors
          </h2>
          <p class="mb-4">
            This interactive tool explores fundamental 2D vector operations. Vectors, possessing
            both magnitude (length) and direction, are visualized as arrows. This application allows
            you to manipulate their components in real-time to understand how different operations
            work both algebraically and geometrically.
          </p>
          <p>
            Use the sliders in the left panel to change the components of the vectors. All
            calculations and charts on this page will update instantly. The current vectors are:
          </p>
          <div class="flex flex-wrap gap-4 my-4">
            <div class="bg-indigo-100 text-indigo-800 p-4 rounded-lg font-mono text-lg shadow">
              Vector v = (<span id="vx-display">2</span>, <span id="vy-display">4</span>)
            </div>
            <div class="bg-teal-100 text-teal-800 p-4 rounded-lg font-mono text-lg shadow">
              Vector w = (<span id="wx-display">5</span>, <span id="wy-display">1</span>)
            </div>
          </div>
        </section>

        <section id="addition" class="mb-16 scroll-mt-20">
          <h3 class="text-2xl font-bold text-slate-900 border-b-2 border-indigo-200 pb-2 mb-4">
            Vector Addition (v + w)
          </h3>
          <p class="mb-6">
            Vector addition sums the corresponding components of each vector. Geometrically, this is
            the "head-to-tail" rule, where the start of one vector is placed at the end of the
            other. The resultant vector connects the origin to the final point. The dashed lines
            form a parallelogram, where the resultant is the main diagonal.
          </p>
          <div class="grid md:grid-cols-2 gap-8 items-center">
            <div class="bg-white p-6 rounded-lg shadow-md">
              <h4 class="font-bold text-lg mb-2">Algebraic Approach</h4>
              <p class="font-mono text-slate-600 mb-4">v + w = (v_x + w_x, v_y + w_y)</p>
              <p class="font-mono text-lg">
                v + w = (<span class="vx-val">2</span> + <span class="wx-val">5</span>,
                <span class="vy-val">4</span> + <span class="wy-val">1</span>)
              </p>
              <p class="font-mono font-bold text-xl text-indigo-600 mt-2">
                Result: <span id="add-result">(7, 5)</span>
              </p>
            </div>
            <div class="chart-container">
              <canvas id="additionChart"></canvas>
            </div>
          </div>
        </section>

        <section id="subtraction" class="mb-16 scroll-mt-20">
          <h3 class="text-2xl font-bold text-slate-900 border-b-2 border-indigo-200 pb-2 mb-4">
            Vector Subtraction (v - w)
          </h3>
          <p class="mb-6">
            Subtracting a vector is the same as adding its inverse (a vector of the same magnitude
            but opposite direction). The resultant vector
            <strong><em>v</em> - <em>w</em></strong> can be visualized as the vector that connects
            the tip of <strong><em>w</em></strong> to the tip of <strong><em>v</em></strong
            >.
          </p>
          <div class="grid md:grid-cols-2 gap-8 items-center">
            <div class="bg-white p-6 rounded-lg shadow-md">
              <h4 class="font-bold text-lg mb-2">Algebraic Approach</h4>
              <p class="font-mono text-slate-600 mb-4">v - w = (v_x - w_x, v_y - w_y)</p>
              <p class="font-mono text-lg">
                v - w = (<span class="vx-val">2</span> - <span class="wx-val">5</span>,
                <span class="vy-val">4</span> - <span class="wy-val">1</span>)
              </p>
              <p class="font-mono font-bold text-xl text-indigo-600 mt-2">
                Result: <span id="sub-result">(-3, 3)</span>
              </p>
            </div>
            <div class="chart-container">
              <canvas id="subtractionChart"></canvas>
            </div>
          </div>
        </section>

        <section id="scalar" class="mb-16 scroll-mt-20">
          <h3 class="text-2xl font-bold text-slate-900 border-b-2 border-indigo-200 pb-2 mb-4">
            Scalar Multiplication (c * v)
          </h3>
          <p class="mb-6">
            Multiplying a vector by a scalar (a single number) scales its magnitude. A positive
            scalar preserves direction, while a negative scalar reverses it. The chart shows vector
            <strong><em>v</em></strong> scaled by constants 2 and -1.5.
          </p>
          <div class="grid md:grid-cols-2 gap-8 items-center">
            <div class="bg-white p-6 rounded-lg shadow-md">
              <h4 class="font-bold text-lg mb-2">Algebraic Approach</h4>
              <p class="font-mono text-slate-600 mb-4">c * v = (c * v_x, c * v_y)</p>
              <p class="font-mono text-lg">
                2 * v = (2 * <span class="vx-val">2</span>, 2 * <span class="vy-val">4</span>) =
                <span class="text-indigo-600 font-bold" id="scalar-pos-result">(4, 8)</span>
              </p>
              <p class="font-mono text-lg mt-2">
                -1.5 * v = (-1.5 * <span class="vx-val">2</span>, -1.5 *
                <span class="vy-val">4</span>) =
                <span class="text-indigo-600 font-bold" id="scalar-neg-result">(-3, -6)</span>
              </p>
            </div>
            <div class="chart-container">
              <canvas id="scalarChart"></canvas>
            </div>
          </div>
        </section>

        <section id="dot" class="mb-16 scroll-mt-20">
          <h3 class="text-2xl font-bold text-slate-900 border-b-2 border-indigo-200 pb-2 mb-4">
            Dot Product (v · w)
          </h3>
          <p class="mb-6">
            The dot product results in a scalar, not a vector. It measures the degree to which two
            vectors point in the same direction. A positive result means they point similarly, zero
            means they're perpendicular, and negative means they point oppositely. The visualization
            shows the projection of <strong><em>v</em></strong> onto <strong><em>w</em></strong
            >, which is the geometric basis of the dot product. The blue dashed arrow represents the
            projection (parallel component), while the gray dashed line shows the perpendicular
            component, together forming a right triangle that decomposes vector
            <strong><em>v</em></strong
            >. The scalar result relates to the length of the blue projection multiplied by the
            length of <strong><em>w</em></strong
            >.
          </p>
          <div class="grid md:grid-cols-2 gap-8 items-center">
            <div class="bg-white p-6 rounded-lg shadow-md">
              <h4 class="font-bold text-lg mb-2">Algebraic Approach</h4>
              <p class="font-mono text-slate-600 mb-4">v · w = (v_x * w_x) + (v_y * w_y)</p>
              <p class="font-mono text-lg">
                v · w = (<span class="vx-val">2</span> * <span class="wx-val">5</span>) + (<span
                  class="vy-val"
                  >4</span
                >
                * <span class="wy-val">1</span>)
              </p>
              <p class="font-mono font-bold text-xl text-indigo-600 mt-2">
                Result: <span id="dot-result">14</span>
              </p>
            </div>
            <div class="chart-container">
              <canvas id="dotProductChart"></canvas>
            </div>
          </div>
        </section>

        <section id="cross" class="mb-16 scroll-mt-20">
          <h3 class="text-2xl font-bold text-slate-900 border-b-2 border-indigo-200 pb-2 mb-4">
            Cross Product (v × w)
          </h3>
          <p class="mb-4">
            The cross product is defined in 3D and produces a new vector perpendicular to the plane
            of the first two. Below you can see the 3D visualization showing how the cross product
            vector emerges perpendicular to both input vectors when we treat our 2D vectors as 3D
            vectors on the XY-plane (<strong><em>v</em></strong> = (v_x, v_y, 0)).
          </p>
          <div class="bg-white p-6 rounded-lg shadow-md">
            <h4 class="font-bold text-lg mb-2">Conceptual Meaning</h4>
            <ul class="list-disc list-inside space-y-2">
              <li>
                <strong>Direction:</strong> Determined by the right-hand rule, the resultant vector
                points along the z-axis (in or out of the screen).
              </li>
              <li>
                <strong>Magnitude:</strong> The length of the resultant vector equals the area of
                the parallelogram formed by <strong><em>v</em></strong> and
                <strong><em>w</em></strong
                >.
              </li>
            </ul>
            <div class="mt-4 pt-4 border-t">
              <h4 class="font-bold text-lg mb-2">Algebraic Result (in 3D)</h4>
              <p class="font-mono text-slate-600 mb-4">z-component = v_x * w_y - v_y * w_x</p>
              <p class="font-mono text-lg">
                z = (<span class="vx-val">2</span> * <span class="wy-val">1</span>) - (<span
                  class="vy-val"
                  >4</span
                >*<span class="wx-val">5</span>) = <span id="cross-calc">2 - 20 = -18</span>
              </p>
              <p class="font-mono font-bold text-xl text-indigo-600 mt-2">
                Result: <span id="cross-result">(0, 0, -18)</span>
              </p>
            </div>
          </div>

          <!-- 3D Cross Product Visualization -->
          <div class="mt-6 bg-white p-6 rounded-lg shadow-md">
            <h4 class="font-bold text-lg mb-4">Cross Product</h4>
            <div class="chart-container">
              <canvas
                id="crossProduct3D"
                class="w-full h-full border border-slate-200 rounded"
              ></canvas>
            </div>
            <p class="text-sm mt-2">
              <strong style="color: #ff0000">Red:</strong> Vector v (<span class="vx-val">2</span>,
              <span class="vy-val">4</span>), <strong style="color: #00aa00">Green:</strong> Vector
              w (<span class="wx-val">5</span>, <span class="wy-val">1</span>),
              <strong style="color: #0000ff">Blue:</strong> Cross product (v × w) =
              <span id="cross-result-3d">(0, 0, -18)</span>
            </p>
          </div>
        </section>
      </main>
    </div>

    <script type="module">
      import * as THREE from "three";

      document.addEventListener("DOMContentLoaded", () => {
        const arrowheadPlugin = {
          id: "arrowhead",
          afterDraw: (chart) => {
            const ctx = chart.ctx;
            chart.data.datasets.forEach((dataset) => {
              if (dataset.hidden || !dataset.showArrow) return;
              const meta = chart.getDatasetMeta(dataset.index);
              const data = dataset.data;
              if (data.length < 2) return;
              const start = meta.data[0];
              const end = meta.data[data.length - 1];

              // Check if start and end exist
              if (!start || !end) return;

              const startX = start.x;
              const startY = start.y;
              const endX = end.x;
              const endY = end.y;
              if (endX === startX && endY === startY) return;
              const angle = Math.atan2(endY - startY, endX - startX);
              const headlen = 10;
              ctx.save();
              ctx.beginPath();
              ctx.moveTo(endX, endY);
              ctx.lineTo(
                endX - headlen * Math.cos(angle - Math.PI / 6),
                endY - headlen * Math.sin(angle - Math.PI / 6)
              );
              ctx.lineTo(
                endX - headlen * Math.cos(angle + Math.PI / 6),
                endY - headlen * Math.sin(angle + Math.PI / 6)
              );
              ctx.closePath();
              ctx.fillStyle = dataset.borderColor;
              ctx.fill();
              ctx.restore();
            });
          },
        };

        Chart.register(arrowheadPlugin);

        let vectorV = { x: 2, y: 4 };
        let vectorW = { x: 5, y: 1 };

        // Initialize ChartManager
        let chartManager;

        // 3D Cross Product Visualization Setup
        let scene, camera, renderer, vectorVMesh, vectorWMesh, crossProductMesh;

        function setup3D() {
          try {
            const canvas = document.getElementById("crossProduct3D");
            const container = canvas.parentElement;

            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf8fafc);

            // Camera setup
            camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
            camera.position.set(8, 6, 8);
            camera.lookAt(0, 0, 0);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            scene.add(directionalLight);

            // Grid and axes
            const gridHelper = new THREE.GridHelper(20, 20, 0xccccc, 0xeeeee);
            scene.add(gridHelper);

            const axesHelper = new THREE.AxesHelper(8);
            scene.add(axesHelper);

            // Vector materials - using MeshBasicMaterial for guaranteed colors
            const vectorVMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // bright red
            const vectorWMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); // bright green
            const crossMaterial = new THREE.MeshBasicMaterial({ color: 0x0000ff }); // bright blue

            // Create vector arrows (will be updated in update3D)
            vectorVMesh = createArrow(vectorVMaterial);
            vectorWMesh = createArrow(vectorWMaterial);
            crossProductMesh = createArrow(crossMaterial);

            scene.add(vectorVMesh);
            scene.add(vectorWMesh);
            scene.add(crossProductMesh);

            // Mouse controls for rotation
            let isMouseDown = false;
            let mouseX = 0,
              mouseY = 0;

            canvas.addEventListener("mousedown", (e) => {
              isMouseDown = true;
              mouseX = e.clientX;
              mouseY = e.clientY;
            });

            canvas.addEventListener("mousemove", (e) => {
              if (!isMouseDown) return;

              const deltaX = e.clientX - mouseX;
              const deltaY = e.clientY - mouseY;

              const spherical = new THREE.Spherical();
              spherical.setFromVector3(camera.position);
              spherical.theta -= deltaX * 0.01;
              spherical.phi += deltaY * 0.01;
              spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

              camera.position.setFromSpherical(spherical);
              camera.lookAt(0, 0, 0);

              mouseX = e.clientX;
              mouseY = e.clientY;
            });

            canvas.addEventListener("mouseup", () => {
              isMouseDown = false;
            });

            // Handle window resize
            window.addEventListener("resize", () => {
              const newWidth = container.clientWidth;
              const newHeight = container.clientHeight;
              camera.aspect = newWidth / newHeight;
              camera.updateProjectionMatrix();
              renderer.setSize(newWidth, newHeight);
            });

            update3D();
          } catch (error) {
            console.error("Error setting up 3D scene:", error);
            console.error("THREE object:", THREE);
          }
        }

        function createArrow(material) {
          const group = new THREE.Group();

          // Arrow shaft (cylinder) - initially 1 unit tall, centered at origin
          const shaftGeometry = new THREE.CylinderGeometry(0.05, 0.05, 1, 8);
          const shaft = new THREE.Mesh(shaftGeometry, material);
          shaft.position.y = 0.5; // Move up so bottom is at origin
          group.add(shaft);

          // Arrow head (cone)
          const headGeometry = new THREE.ConeGeometry(0.15, 0.3, 8);
          const head = new THREE.Mesh(headGeometry, material);
          head.position.y = 1.15; // Position at top of shaft
          group.add(head);

          return group;
        }

        function update3D() {
          if (!renderer) return;

          // Calculate cross product (v × w)
          const crossZ = vectorV.x * vectorW.y - vectorV.y * vectorW.x;

          // Map 2D vectors to 3D: (x,y) -> (y,0,x) to match visual expectation
          // This puts vectors flat on the XZ-plane with correct proportions

          // Update vector V (red) - lies in XZ plane (y=0)
          updateArrow(vectorVMesh, vectorV.y, 0, vectorV.x);

          // Update vector W (green) - lies in XZ plane (y=0)
          updateArrow(vectorWMesh, vectorW.y, 0, vectorW.x); // Update cross product (blue) - points along Y axis (vertical)
          updateArrow(crossProductMesh, 0, crossZ, 0);

          // Render the scene
          renderer.render(scene, camera);
        }
        function updateArrow(arrowGroup, x, y, z) {
          const length = Math.sqrt(x * x + y * y + z * z);

          if (length < 0.1) {
            arrowGroup.visible = false;
            return;
          }

          arrowGroup.visible = true;

          // Reset transforms
          arrowGroup.position.set(0, 0, 0);
          arrowGroup.rotation.set(0, 0, 0);
          arrowGroup.scale.set(1, 1, 1);

          // Scale the entire arrow to match vector length with better visibility
          const scale = Math.max(0.5, length * 0.8); // Scale factor for better visibility
          arrowGroup.scale.set(1, scale, 1);

          // Position and orient the arrow
          const direction = new THREE.Vector3(x, y, z).normalize();
          arrowGroup.lookAt(direction);
          arrowGroup.rotateX(Math.PI / 2); // Adjust for cylinder orientation
        }

        // Clean Chart Management System
        class ChartManager {
          constructor() {
            this.charts = {};
            this.commonOptions = {
              type: "scatter",
              options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                  x: { grid: { color: "#e2e8f0" }, ticks: { color: "#64748b" }, min: -15, max: 15 },
                  y: { grid: { color: "#e2e8f0" }, ticks: { color: "#64748b" }, min: -15, max: 15 },
                },
                plugins: {
                  legend: { display: false },
                  tooltip: { enabled: false },
                },
                elements: { line: { tension: 0 } },
                showLine: true,
                animation: { duration: 0 },
              },
            };

            this.init();
          }

          init() {
            this.createCharts();
          }

          // Create vector dataset with consistent formatting
          createVectorDataset(vector, color, from = { x: 0, y: 0 }, borderDash = []) {
            return {
              data: [
                { x: from.x, y: from.y },
                { x: vector.x + from.x, y: vector.y + from.y },
              ],
              borderColor: color,
              borderWidth: 3,
              pointRadius: 0,
              borderDash: borderDash,
              showArrow: borderDash.length === 0,
            };
          }

          // Create all charts with common configuration
          createCharts() {
            const chartIds = [
              "additionChart",
              "subtractionChart",
              "scalarChart",
              "dotProductChart",
            ];
            const chartKeys = ["addition", "subtraction", "scalar", "dot"];

            chartIds.forEach((id, index) => {
              this.charts[chartKeys[index]] = new Chart(
                document.getElementById(id),
                structuredClone(this.commonOptions)
              );
            });
          }

          // Update all charts with current vector values
          updateCharts(vectorV, vectorW) {
            this.updateAdditionChart(vectorV, vectorW);
            this.updateSubtractionChart(vectorV, vectorW);
            this.updateScalarChart(vectorV);
            this.updateDotProductChart(vectorV, vectorW);
          }

          updateAdditionChart(vectorV, vectorW) {
            const vPlusW = { x: vectorV.x + vectorW.x, y: vectorV.y + vectorW.y };
            this.charts.addition.data.datasets = [
              this.createVectorDataset(vectorW, "#86efac", vectorV, [5, 5]),
              this.createVectorDataset(vectorV, "#ef4444"),
              this.createVectorDataset(vectorW, "#10b981"),
              this.createVectorDataset(vPlusW, "#3b82f6"),
            ];
            this.charts.addition.update();
          }

          updateSubtractionChart(vectorV, vectorW) {
            const vMinusW = { x: vectorV.x - vectorW.x, y: vectorV.y - vectorW.y };
            this.charts.subtraction.data.datasets = [
              this.createVectorDataset(vectorV, "#ef4444"),
              this.createVectorDataset(vectorW, "#10b981"),
              this.createVectorDataset(vMinusW, "#3b82f6", vectorW),
            ];
            this.charts.subtraction.update();
          }

          updateScalarChart(vectorV) {
            const scalar2v = { x: vectorV.x * 2, y: vectorV.y * 2 };
            const scalarNegV = { x: vectorV.x * -1.5, y: vectorV.y * -1.5 };
            this.charts.scalar.data.datasets = [
              this.createVectorDataset(vectorV, "#fca5a5", { x: 0, y: 0 }, [5, 5]),
              this.createVectorDataset(scalar2v, "#3b82f6"),
              this.createVectorDataset(scalarNegV, "#6366f1"),
            ];
            this.charts.scalar.update();
          }

          updateDotProductChart(vectorV, vectorW) {
            const dot = vectorV.x * vectorW.x + vectorV.y * vectorW.y;
            const wMagSq = vectorW.x ** 2 + vectorW.y ** 2;
            const projScalar = wMagSq === 0 ? 0 : dot / wMagSq;
            const proj = { x: vectorW.x * projScalar, y: vectorW.y * projScalar };

            this.charts.dot.data.datasets = [
              // Vector V (red)
              {
                data: [
                  { x: 0, y: 0 },
                  { x: vectorV.x, y: vectorV.y },
                ],
                borderColor: "#ef4444",
                borderWidth: 3,
                pointRadius: 0,
                showArrow: true,
                showLine: true,
                fill: false,
              },
              // Vector W (green)
              {
                data: [
                  { x: 0, y: 0 },
                  { x: vectorW.x, y: vectorW.y },
                ],
                borderColor: "#10b981",
                borderWidth: 3,
                pointRadius: 0,
                showArrow: true,
                showLine: true,
                fill: false,
              },
              // Projection (blue)
              {
                data: [
                  { x: vectorV.x, y: vectorV.y },
                  { x: proj.x, y: proj.y },
                ],
                borderColor: "#3b82f6",
                backgroundColor: "#3b82f6",
                borderWidth: 6,
                pointRadius: 0,
                borderDash: [],
                showArrow: false,
                fill: false,
                showLine: true,
                tension: 0,
              },
              // Perpendicular line (gray)
              {
                data: [
                  { x: vectorV.x, y: vectorV.y },
                  { x: proj.x, y: proj.y },
                ],
                borderColor: "#9ca3af",
                backgroundColor: "#9ca3af",
                borderWidth: 2,
                pointRadius: 0,
                borderDash: [5, 5],
                showArrow: false,
                fill: false,
                showLine: true,
                tension: 0,
              },
            ];
            this.charts.dot.update();
          }
        }

        function updatePage() {
          updateCalculations();
          chartManager.updateCharts(vectorV, vectorW);
          update3D();
        }

        function updateCalculations() {
          const f = (n) => n.toFixed(1).replace(".0", "");

          // Update sidebar controls and readouts
          document.getElementById("vx-display").textContent = f(vectorV.x);
          document.getElementById("vy-display").textContent = f(vectorV.y);
          document.getElementById("wx-display").textContent = f(vectorW.x);
          document.getElementById("wy-display").textContent = f(vectorW.y);
          document.getElementById("vx-val-display").textContent = f(vectorV.x);
          document.getElementById("vy-val-display").textContent = f(vectorV.y);
          document.getElementById("wx-val-display").textContent = f(vectorW.x);
          document.getElementById("wy-val-display").textContent = f(vectorW.y);

          const vMag = Math.sqrt(vectorV.x ** 2 + vectorV.y ** 2);
          const vAngle = Math.atan2(vectorV.y, vectorV.x) * (180 / Math.PI);
          document.getElementById("v-mag-display").textContent = vMag.toFixed(2);
          document.getElementById("v-angle-display").textContent = `${vAngle.toFixed(1)}°`;

          const wMag = Math.sqrt(vectorW.x ** 2 + vectorW.y ** 2);
          const wAngle = Math.atan2(vectorW.y, vectorW.x) * (180 / Math.PI);
          document.getElementById("w-mag-display").textContent = wMag.toFixed(2);
          document.getElementById("w-angle-display").textContent = `${wAngle.toFixed(1)}°`;

          // Update calculation text in main content
          document.querySelectorAll(".vx-val").forEach((el) => (el.textContent = f(vectorV.x)));
          document.querySelectorAll(".vy-val").forEach((el) => (el.textContent = f(vectorV.y)));
          document.querySelectorAll(".wx-val").forEach((el) => (el.textContent = f(vectorW.x)));
          document.querySelectorAll(".wy-val").forEach((el) => (el.textContent = f(vectorW.y)));

          const vPlusW = { x: vectorV.x + vectorW.x, y: vectorV.y + vectorW.y };
          document.getElementById("add-result").textContent = `(${f(vPlusW.x)}, ${f(vPlusW.y)})`;

          const vMinusW = { x: vectorV.x - vectorW.x, y: vectorV.y - vectorW.y };
          document.getElementById("sub-result").textContent = `(${f(vMinusW.x)}, ${f(vMinusW.y)})`;

          const scalar2v = { x: vectorV.x * 2, y: vectorV.y * 2 };
          document.getElementById("scalar-pos-result").textContent = `(${f(scalar2v.x)}, ${f(
            scalar2v.y
          )})`;
          const scalarNegV = { x: vectorV.x * -1.5, y: vectorV.y * -1.5 };
          document.getElementById("scalar-neg-result").textContent = `(${f(scalarNegV.x)}, ${f(
            scalarNegV.y
          )})`;

          const dot = vectorV.x * vectorW.x + vectorV.y * vectorW.y;
          document.getElementById("dot-result").textContent = dot.toFixed(2);

          const cross = vectorV.x * vectorW.y - vectorV.y * vectorW.x;
          const p1 = vectorV.x * vectorW.y;
          const p2 = vectorV.y * vectorW.x;
          document.getElementById("cross-calc").textContent = `${f(p1)} - (${f(p2)}) = ${f(cross)}`;
          document.getElementById("cross-result").textContent = `(0, 0, ${f(cross)})`;

          // Update 3D cross product result to match algebraic convention (3rd component)
          if (document.getElementById("cross-result-3d")) {
            document.getElementById("cross-result-3d").textContent = `(0, 0, ${f(cross)})`;
          }
        }

        // Initialize components
        chartManager = new ChartManager();
        setup3D();
        updatePage();

        ["vx", "vy", "wx", "wy"].forEach((id) => {
          const slider = document.getElementById(id);
          slider.addEventListener("input", (e) => {
            const val = parseFloat(e.target.value);
            if (id === "vx") vectorV.x = val;
            if (id === "vy") vectorV.y = val;
            if (id === "wx") vectorW.x = val;
            if (id === "wy") vectorW.y = val;
            updatePage();
          });
        });

        const navLinks = document.querySelectorAll(".nav-link");
        const sections = document.querySelectorAll("main section");

        // Clean Navigation Highlighting System
        class NavigationController {
          constructor(navLinks, sections) {
            this.navLinks = navLinks;
            this.sections = sections;
            this.hasScrolled = false;
            this.scrollDetectionDisabled = false;

            this.init();
          }

          init() {
            // Initial setup
            this.highlightSection("introduction");
            window.scrollTo(0, 0);

            // Bind events
            this.bindScrollEvents();
            this.bindClickEvents();
          }

          // Single source of truth for highlighting
          highlightSection(sectionId) {
            this.navLinks.forEach((link) => link.classList.remove("active"));
            const activeLink = document.querySelector(`a[href="#${sectionId}"]`);
            if (activeLink) {
              activeLink.classList.add("active");
            }
          }

          // Throttle function for performance
          throttle(func, delay) {
            let timeoutId;
            let lastExecTime = 0;
            return (...args) => {
              const currentTime = Date.now();
              if (currentTime - lastExecTime > delay) {
                func.apply(this, args);
                lastExecTime = currentTime;
              } else {
                clearTimeout(timeoutId);
                timeoutId = setTimeout(() => {
                  func.apply(this, args);
                  lastExecTime = Date.now();
                }, delay - (currentTime - lastExecTime));
              }
            };
          }

          // Determine active section based on scroll position
          getActiveSectionFromScroll() {
            const scrollTop = window.scrollY;
            const windowHeight = window.innerHeight;
            const documentHeight = document.documentElement.scrollHeight;

            // Special case: top of page
            if (scrollTop === 0) {
              return "introduction";
            }

            // Special case: bottom of page
            if (scrollTop + windowHeight >= documentHeight - 10) {
              return this.sections[this.sections.length - 1].getAttribute("id");
            }

            // Find section at top of viewport
            let activeSection = null;
            this.sections.forEach((section) => {
              const rect = section.getBoundingClientRect();
              const sectionTop = scrollTop + rect.top;

              if (sectionTop <= scrollTop + 100) {
                activeSection = section.getAttribute("id");
              }
            });

            return activeSection;
          }

          // Handle scroll-based highlighting
          handleScroll() {
            if (this.scrollDetectionDisabled) return;

            const activeSection = this.getActiveSectionFromScroll();
            if (activeSection) {
              this.highlightSection(activeSection);
            }
          }

          // Handle navigation clicks
          handleNavClick(event) {
            const link = event.currentTarget;
            const targetId = link.getAttribute("href").substring(1);

            // Temporarily disable scroll detection
            this.scrollDetectionDisabled = true;
            this.highlightSection(targetId);

            // Re-enable after navigation completes
            setTimeout(() => {
              this.scrollDetectionDisabled = false;
            }, 1000);
          }

          // Activate scroll detection after first scroll
          activateScrollDetection() {
            if (!this.hasScrolled) {
              this.hasScrolled = true;
              const throttledHandler = this.throttle(this.handleScroll.bind(this), 16); // ~60fps
              window.addEventListener("scroll", throttledHandler);
            }
          }

          // Bind all event listeners
          bindScrollEvents() {
            // One-time activation
            window.addEventListener("scroll", this.activateScrollDetection.bind(this), {
              once: true,
            });
          }

          bindClickEvents() {
            this.navLinks.forEach((link) => {
              link.addEventListener("click", this.handleNavClick.bind(this));
            });
          }
        }

        // Initialize the navigation system
        const navigationController = new NavigationController(navLinks, sections);

        // Reset button functionality
        document.getElementById("reset-button").addEventListener("click", () => {
          // Reset to default values and trigger change events
          const vxSlider = document.getElementById("vx");
          const vySlider = document.getElementById("vy");
          const wxSlider = document.getElementById("wx");
          const wySlider = document.getElementById("wy");

          vxSlider.value = 2;
          vySlider.value = 4;
          wxSlider.value = 5;
          wySlider.value = 1;

          // Trigger input events to update displays and charts
          vxSlider.dispatchEvent(new Event("input"));
          vySlider.dispatchEvent(new Event("input"));
          wxSlider.dispatchEvent(new Event("input"));
          wySlider.dispatchEvent(new Event("input"));
        });
      });
    </script>
  </body>
</html>
